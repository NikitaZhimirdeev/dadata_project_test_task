import DB_modul
#
from dadata import Dadata
import httpx

# Объявляем БД SQLite3
SQLighter = DB_modul.SQLighter('database.db')

# Проверяем наличие необходимой таблицы, если ее нет, то создаем
SQLighter.create_table()


# Форма ввода логина и пароля
def write_login_pswrd():
    login = input('\nВведите логин: ')
    password = input('Введите пароль: ')

    return login.strip(), password.strip()


# Функция реализации сценария входа в личный кабинет
def sign_in():
    # Цикл предотвращения ошибок и опечаток пользователя
    while True:
        # Вызов формы ввода логина и пароля, возвращает введенные данные
        login, password = write_login_pswrd()

        # Проверка на существование введенного логина, если он существует в БД, то продолжаем вход,
        # если его нет, отрабатываем исключение
        if SQLighter.login_verification(login):
            # Получаем данные о пользователе по введенному логину
            DATA = SQLighter.login_v(login)
            # Проверяем правильность введенного пароля, если пароли сопрадают, то возвращаем данные о пользователе
            if DATA[0][1] == password:
                API_key = DATA[0][2]
                secret = DATA[0][3]
                lang = DATA[0][4]
                return login, password, API_key, secret, lang
            else:
                print('Неверный пароль')
                # Исключение если пароли не совпадают, предлагаем повторить вход или выйти в меню регистрации
                otmena = input(
                    'Для отмены входа и выхода на главное меню введите "отмена", для повторной авторизании введите '
                    'любой символ: ')
                if otmena.strip() == 'отмена':
                    return '0', '', '', '', ''

        else:
            print('Неверный логин')
            # Если логин введен не правильно, предлагаем повторить вход или выйти в меню регистрации
            otmena = input('Для отмены входа и выхода на главное меню введите "отмена", для повторной авторизании введите '
                    'любой символ: ')
            if otmena.strip() == 'отмена':
                return '0', '', '', '', ''


# Функция для сценария регистрации нового пользователя
def sign_up():
    # Цикл для избежания ошибок пользователя и проверки логина
    while True:
        # Вызов формы ввода логина и пароля, возвращает введенные данные
        login, password = write_login_pswrd()

        # Проверка на оригинальность логина
        if SQLighter.login_verification(login):
            print('Данный логин уже зарегистрирован, введите другой\n')
            otmena = input('Для отмены регистрации и перехода в меню введите "отмена", для продолжения любой другой символ: ')
            if otmena.strip() == 'отмена':
                return '0', '', '', '', ''
        else:
            break

    # Ввод API ключа из личного кабинета dadata
    API_key = input('Для завершения регистрации необходимо заполнить еще несколько полей.\n'
                    'Введите API_key из личного кабинета: ')

    # Ввод secret ключа из личного кабинета dadata
    secret = input('Введите secret из личного кабинета: ')

    # Цикл предотвращения ошибок и опечаток пользователя
    while True:
        # Ввод языка вывода результата
        lang = input('Введите язык на котором хотите получать результат (ru или en): ').strip()

        # Проверка правильности введенного языка
        if lang == 'ru' or lang == 'en':
            break
        else:
            print('Ввели не верное значение, повторите действие.\n')

    # Добавляем пользователя в БД
    SQLighter.add_user(login, password, API_key, secret, lang)

    # Возвращаем резульатат регистраии
    return login, password, API_key, secret, lang


# Функция по запросу адреса, вывода вариантов для выбора, и определения наиболее подходящего варианта адреса
def search_for_address(API_key, secret, lang):
    # Цикл для повтора ввода адреса поиска
    while True:
        # запрос пользователя на ввод адреса
        find_addres = input('\nВведите точный или приблизительный адрес, координаты которого необходимо узнать: ')

        # Открываем сессию через библиотеку официальную dadata
        with Dadata(API_key, secret) as dadata:
            # Отрабатываем исключение на разрыв соединения с dadata
            try:
                # Получаем список возможных адресов
                result = dadata.suggest(name="address", query=find_addres, language=lang)
            except httpx.HTTPStatusError:
                # Отрабатываем исключение ошибки запроса
                while True:
                    # Даем выбор пользователю на повтор запроса или выход в главное меню
                    otmena = input('\nНе получается получить доступ, возможно ввели не верный API_key или secret.\n'
                          'Для повторной попытки введите 1, для выхода в главное меню введите 2: ').strip()

                    if otmena == '1' or otmena == '2':
                        break
                    else:
                        print('Ввели неверное значение\n')

                return otmena

        # Объявляем словарь для возможных вариантов адресов
        Options= {}
        i = 1
        # Формируем сообщение для пользователя с вариантами адресов
        # заполняем словарь
        for option in result:
            print(f"{i} - {option['value']}")
            Options[str(i)] = option['value']
            i += 1

        # Добавляем варинт изменения адреса
        print(f"0 - Ввести другой адрес")

        # Цикл корректности ввода варианта адреса
        while True:
            # Просим пользователя ввести номер наиболее подходящего адреса
            option_num = input('\nВведите номер наиболее подходящего адреса: ')

            # Отрабатываем варианты ввода пользователя
            # Вариант с изменением адреса
            if option_num == '0':
                break
            # Возвращаем выбранный пользователем адрес
            elif option_num.strip() in Options:
                return Options[option_num.strip()]
            # отрабатываем ошибку ввода номера адреса
            else:
                print('Ввели некорректный номер')


# Функция поиска координат по выбранному адресу
def find_coord(API_key, secret, option):
    # Открываем сессию через библиотеку официальную dadata
    with Dadata(API_key, secret) as dadata:

        # Получаем координаты
        result = dadata.clean("address", option)

        # Сообщение пользователю с полученными координатами
        print()
        print(f'Координаты по адресу "{option}": {result["geo_lat"]} : {result["geo_lon"]}')

